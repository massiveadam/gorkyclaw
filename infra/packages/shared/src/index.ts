/**
 * OpenClaw Shared Types and Schemas
 * Used by gateway, ops-runner, and NanoClaw
 */

import { z } from 'zod';

// ============================================================================
// Action Types
// ============================================================================

export const ActionType = z.enum([
  'ssh',
  'obsidian_write',
  'web_fetch',
  'notify',
]);
export type ActionType = z.infer<typeof ActionType>;

// ============================================================================
// Risk Levels
// ============================================================================

export const RiskLevel = z.enum(['none', 'low', 'medium', 'high', 'critical']);
export type RiskLevel = z.infer<typeof RiskLevel>;

// ============================================================================
// Action Schema (for NanoClaw plan output)
// ============================================================================

const BaseActionSchema = z.object({
  id: z.string().optional(), // Generated by gateway if not provided
  type: ActionType,
  risk: RiskLevel.default('low'),
  requiresApproval: z.boolean().default(true),
  reason: z.string(), // Explanation of what this action does
  timeout: z.number().optional(), // Seconds, defaults to 60
});

const SSHActionSchema = BaseActionSchema.extend({
  type: z.literal('ssh'),
  target: z.enum(['william', 'willy-ubuntu']),
  command: z.string().min(1),
});

const ObsidianWriteActionSchema = BaseActionSchema.extend({
  type: z.literal('obsidian_write'),
  path: z.string().min(1),
  patch: z.string().min(1),
});

const WebFetchActionSchema = BaseActionSchema.extend({
  type: z.literal('web_fetch'),
  url: z.string().url(),
  mode: z.enum(['http', 'browser']).default('http'),
  extract: z.string().optional(),
});

const NotifyActionSchema = BaseActionSchema.extend({
  type: z.literal('notify'),
  message: z.string().min(1),
});

export const ActionSchema = z.discriminatedUnion('type', [
  SSHActionSchema,
  ObsidianWriteActionSchema,
  WebFetchActionSchema,
  NotifyActionSchema,
]);

export type Action = z.infer<typeof ActionSchema>;

// ============================================================================
// Plan Schema (NanoClaw structured output)
// ============================================================================

export const PlanSchema = z.object({
  version: z.literal('1.0'),
  summary: z.string(), // Human-readable summary of the plan
  actions: z.array(ActionSchema).min(1),
  estimatedDuration: z.number().optional(), // Seconds
});

export type Plan = z.infer<typeof PlanSchema>;

// ============================================================================
// Job Status
// ============================================================================

export const JobStatus = z.enum([
  'proposed',
  'approved',
  'denied',
  'executing',
  'executed',
  'failed',
  'cancelled',
]);
export type JobStatus = z.infer<typeof JobStatus>;

// ============================================================================
// Job Schema (database)
// ============================================================================

export const JobSchema = z.object({
  id: z.string(), // UUID v4
  createdAt: z.string().datetime(), // ISO 8601
  status: JobStatus,
  requestedBy: z.object({
    telegramUserId: z.number(),
    username: z.string().optional(),
    firstName: z.string(),
    lastName: z.string().optional(),
  }),
  plan: PlanSchema,
  // Execution tracking
  requiresApproval: z.boolean(),
  approvedAt: z.string().datetime().optional(),
  approvedBy: z.number().optional(), // telegram user id
  deniedAt: z.string().datetime().optional(),
  deniedReason: z.string().optional(),
  executedAt: z.string().datetime().optional(),
  // Results
  results: z
    .array(
      z.object({
        actionId: z.string(),
        stdout: z.string(),
        stderr: z.string(),
        exitCode: z.number(),
        executedAt: z.string().datetime(),
        durationMs: z.number(),
      }),
    )
    .optional(),
  error: z.string().optional(),
  // Obsidian logging
  notesPath: z.string().optional(),
});

export type Job = z.infer<typeof JobSchema>;

// ============================================================================
// API Types
// ============================================================================

export const RunJobRequestSchema = z.object({
  jobId: z.string(),
  sharedSecret: z.string(),
});

export type RunJobRequest = z.infer<typeof RunJobRequestSchema>;

export const RunJobResponseSchema = z.object({
  success: z.boolean(),
  jobId: z.string(),
  results: z
    .array(
      z.object({
        actionId: z.string(),
        stdout: z.string(),
        stderr: z.string(),
        exitCode: z.number(),
        executedAt: z.string().datetime(),
        durationMs: z.number(),
      }),
    )
    .optional(),
  error: z.string().optional(),
});

export type RunJobResponse = z.infer<typeof RunJobResponseSchema>;

// ============================================================================
// Policy Types
// ============================================================================

export const PolicyRuleSchema = z.object({
  pattern: z.string(), // Regex pattern
  description: z.string(),
  action: z.enum(['allow', 'deny', 'require_approval']),
  risk: RiskLevel.default('low'),
});

export type PolicyRule = z.infer<typeof PolicyRuleSchema>;

export const PolicyConfigSchema = z.object({
  targets: z.record(
    z.string(),
    z.object({
      allowlist: z.array(PolicyRuleSchema),
      defaultAction: z
        .enum(['allow', 'deny', 'require_approval'])
        .default('require_approval'),
    }),
  ),
  diagnostics: z
    .object({
      allowedWithoutApproval: z.boolean().default(true),
      patterns: z.array(z.string()), // e.g., ["uptime", "df -h", "free -m"]
    })
    .default({
      allowedWithoutApproval: true,
      patterns: [
        '^uptime$',
        '^df\\s+-h$',
        '^free\\s+-m$',
        '^top\\s+-bn1$',
        '^ps\\s+aux$',
      ],
    }),
});

export type PolicyConfig = z.infer<typeof PolicyConfigSchema>;

// ============================================================================
// NanoClaw Integration Types
// ============================================================================

export const NanoClawRequestSchema = z.object({
  message: z.string(),
  userId: z.number(),
  username: z.string().optional(),
  chatId: z.number(),
  context: z
    .array(
      z.object({
        role: z.enum(['user', 'assistant']),
        content: z.string(),
        timestamp: z.string().datetime(),
      }),
    )
    .optional(),
});

export type NanoClawRequest = z.infer<typeof NanoClawRequestSchema>;

export const NanoClawResponseSchema = z.object({
  plan: PlanSchema.optional(),
  error: z.string().optional(),
  rawResponse: z.string().optional(), // For debugging
});

export type NanoClawResponse = z.infer<typeof NanoClawResponseSchema>;

export { JobsDatabase } from './db.js';
